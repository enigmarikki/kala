// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod tx {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_TX_BODY: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_TX_BODY: u8 = 6;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_TX_BODY: [TxBody; 7] = [
        TxBody::NONE,
        TxBody::SendTx,
        TxBody::MintTx,
        TxBody::BurnTx,
        TxBody::StakeTx,
        TxBody::UnstakeTx,
        TxBody::SolveTx,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct TxBody(pub u8);
    #[allow(non_upper_case_globals)]
    impl TxBody {
        pub const NONE: Self = Self(0);
        pub const SendTx: Self = Self(1);
        pub const MintTx: Self = Self(2);
        pub const BurnTx: Self = Self(3);
        pub const StakeTx: Self = Self(4);
        pub const UnstakeTx: Self = Self(5);
        pub const SolveTx: Self = Self(6);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 6;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::SendTx,
            Self::MintTx,
            Self::BurnTx,
            Self::StakeTx,
            Self::UnstakeTx,
            Self::SolveTx,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::SendTx => Some("SendTx"),
                Self::MintTx => Some("MintTx"),
                Self::BurnTx => Some("BurnTx"),
                Self::StakeTx => Some("StakeTx"),
                Self::UnstakeTx => Some("UnstakeTx"),
                Self::SolveTx => Some("SolveTx"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for TxBody {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for TxBody {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for TxBody {
        type Output = TxBody;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for TxBody {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for TxBody {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for TxBody {}
    pub struct TxBodyUnionTableOffset {}

    pub enum SendTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SendTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SendTx<'a> {
        type Inner = SendTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SendTx<'a> {
        pub const VT_SENDER: flatbuffers::VOffsetT = 4;
        pub const VT_RECEIVER: flatbuffers::VOffsetT = 6;
        pub const VT_DENOM: flatbuffers::VOffsetT = 8;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 10;
        pub const VT_NONCE: flatbuffers::VOffsetT = 12;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 14;
        pub const VT_GAS_SPONSORER: flatbuffers::VOffsetT = 16;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SendTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SendTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<SendTx<'bldr>> {
            let mut builder = SendTxBuilder::new(_fbb);
            builder.add_nonce(args.nonce);
            builder.add_amount(args.amount);
            if let Some(x) = args.gas_sponsorer {
                builder.add_gas_sponsorer(x);
            }
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.denom {
                builder.add_denom(x);
            }
            if let Some(x) = args.receiver {
                builder.add_receiver(x);
            }
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn sender(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SendTx::VT_SENDER,
                        None,
                    )
            }
        }
        #[inline]
        pub fn receiver(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SendTx::VT_RECEIVER,
                        None,
                    )
            }
        }
        #[inline]
        pub fn denom(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SendTx::VT_DENOM,
                        None,
                    )
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(SendTx::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn nonce(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(SendTx::VT_NONCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SendTx::VT_SIGNATURE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn gas_sponsorer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SendTx::VT_GAS_SPONSORER,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for SendTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "sender",
                    Self::VT_SENDER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "receiver",
                    Self::VT_RECEIVER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "denom",
                    Self::VT_DENOM,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "signature",
                    Self::VT_SIGNATURE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "gas_sponsorer",
                    Self::VT_GAS_SPONSORER,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SendTxArgs<'a> {
        pub sender: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub receiver: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub denom: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub amount: u64,
        pub nonce: u64,
        pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub gas_sponsorer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for SendTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            SendTxArgs {
                sender: None,
                receiver: None,
                denom: None,
                amount: 0,
                nonce: 0,
                signature: None,
                gas_sponsorer: None,
            }
        }
    }

    pub struct SendTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SendTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTx::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_receiver(
            &mut self,
            receiver: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTx::VT_RECEIVER, receiver);
        }
        #[inline]
        pub fn add_denom(&mut self, denom: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTx::VT_DENOM, denom);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(SendTx::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u64) {
            self.fbb_.push_slot::<u64>(SendTx::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn add_signature(
            &mut self,
            signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SendTx::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn add_gas_sponsorer(
            &mut self,
            gas_sponsorer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SendTx::VT_GAS_SPONSORER,
                gas_sponsorer,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SendTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SendTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SendTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SendTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SendTx");
            ds.field("sender", &self.sender());
            ds.field("receiver", &self.receiver());
            ds.field("denom", &self.denom());
            ds.field("amount", &self.amount());
            ds.field("nonce", &self.nonce());
            ds.field("signature", &self.signature());
            ds.field("gas_sponsorer", &self.gas_sponsorer());
            ds.finish()
        }
    }
    pub enum MintTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MintTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MintTx<'a> {
        type Inner = MintTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MintTx<'a> {
        pub const VT_SENDER: flatbuffers::VOffsetT = 4;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
        pub const VT_DENOM: flatbuffers::VOffsetT = 8;
        pub const VT_NONCE: flatbuffers::VOffsetT = 10;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 12;
        pub const VT_GAS_SPONSORER: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MintTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args MintTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<MintTx<'bldr>> {
            let mut builder = MintTxBuilder::new(_fbb);
            builder.add_nonce(args.nonce);
            builder.add_amount(args.amount);
            if let Some(x) = args.gas_sponsorer {
                builder.add_gas_sponsorer(x);
            }
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.denom {
                builder.add_denom(x);
            }
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn sender(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        MintTx::VT_SENDER,
                        None,
                    )
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(MintTx::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn denom(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        MintTx::VT_DENOM,
                        None,
                    )
            }
        }
        #[inline]
        pub fn nonce(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(MintTx::VT_NONCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        MintTx::VT_SIGNATURE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn gas_sponsorer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        MintTx::VT_GAS_SPONSORER,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for MintTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "sender",
                    Self::VT_SENDER,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "denom",
                    Self::VT_DENOM,
                    false,
                )?
                .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "signature",
                    Self::VT_SIGNATURE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "gas_sponsorer",
                    Self::VT_GAS_SPONSORER,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct MintTxArgs<'a> {
        pub sender: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub amount: u64,
        pub denom: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub nonce: u64,
        pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub gas_sponsorer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for MintTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            MintTxArgs {
                sender: None,
                amount: 0,
                denom: None,
                nonce: 0,
                signature: None,
                gas_sponsorer: None,
            }
        }
    }

    pub struct MintTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MintTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MintTx::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(MintTx::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_denom(&mut self, denom: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MintTx::VT_DENOM, denom);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u64) {
            self.fbb_.push_slot::<u64>(MintTx::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn add_signature(
            &mut self,
            signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(MintTx::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn add_gas_sponsorer(
            &mut self,
            gas_sponsorer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                MintTx::VT_GAS_SPONSORER,
                gas_sponsorer,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> MintTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            MintTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MintTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MintTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MintTx");
            ds.field("sender", &self.sender());
            ds.field("amount", &self.amount());
            ds.field("denom", &self.denom());
            ds.field("nonce", &self.nonce());
            ds.field("signature", &self.signature());
            ds.field("gas_sponsorer", &self.gas_sponsorer());
            ds.finish()
        }
    }
    pub enum BurnTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct BurnTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for BurnTx<'a> {
        type Inner = BurnTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> BurnTx<'a> {
        pub const VT_SENDER: flatbuffers::VOffsetT = 4;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
        pub const VT_DENOM: flatbuffers::VOffsetT = 8;
        pub const VT_NONCE: flatbuffers::VOffsetT = 10;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 12;
        pub const VT_GAS_SPONSORER: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            BurnTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args BurnTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<BurnTx<'bldr>> {
            let mut builder = BurnTxBuilder::new(_fbb);
            builder.add_nonce(args.nonce);
            builder.add_amount(args.amount);
            if let Some(x) = args.gas_sponsorer {
                builder.add_gas_sponsorer(x);
            }
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.denom {
                builder.add_denom(x);
            }
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn sender(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        BurnTx::VT_SENDER,
                        None,
                    )
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(BurnTx::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn denom(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        BurnTx::VT_DENOM,
                        None,
                    )
            }
        }
        #[inline]
        pub fn nonce(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(BurnTx::VT_NONCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        BurnTx::VT_SIGNATURE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn gas_sponsorer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        BurnTx::VT_GAS_SPONSORER,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for BurnTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "sender",
                    Self::VT_SENDER,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "denom",
                    Self::VT_DENOM,
                    false,
                )?
                .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "signature",
                    Self::VT_SIGNATURE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "gas_sponsorer",
                    Self::VT_GAS_SPONSORER,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct BurnTxArgs<'a> {
        pub sender: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub amount: u64,
        pub denom: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub nonce: u64,
        pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub gas_sponsorer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for BurnTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            BurnTxArgs {
                sender: None,
                amount: 0,
                denom: None,
                nonce: 0,
                signature: None,
                gas_sponsorer: None,
            }
        }
    }

    pub struct BurnTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> BurnTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BurnTx::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(BurnTx::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_denom(&mut self, denom: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BurnTx::VT_DENOM, denom);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u64) {
            self.fbb_.push_slot::<u64>(BurnTx::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn add_signature(
            &mut self,
            signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(BurnTx::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn add_gas_sponsorer(
            &mut self,
            gas_sponsorer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                BurnTx::VT_GAS_SPONSORER,
                gas_sponsorer,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> BurnTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            BurnTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<BurnTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for BurnTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("BurnTx");
            ds.field("sender", &self.sender());
            ds.field("amount", &self.amount());
            ds.field("denom", &self.denom());
            ds.field("nonce", &self.nonce());
            ds.field("signature", &self.signature());
            ds.field("gas_sponsorer", &self.gas_sponsorer());
            ds.finish()
        }
    }
    pub enum StakeTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StakeTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StakeTx<'a> {
        type Inner = StakeTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> StakeTx<'a> {
        pub const VT_DELEGATOR: flatbuffers::VOffsetT = 4;
        pub const VT_WITNESS: flatbuffers::VOffsetT = 6;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 8;
        pub const VT_NONCE: flatbuffers::VOffsetT = 10;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 12;
        pub const VT_GAS_SPONSORER: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StakeTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args StakeTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<StakeTx<'bldr>> {
            let mut builder = StakeTxBuilder::new(_fbb);
            builder.add_nonce(args.nonce);
            builder.add_amount(args.amount);
            if let Some(x) = args.gas_sponsorer {
                builder.add_gas_sponsorer(x);
            }
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.witness {
                builder.add_witness(x);
            }
            if let Some(x) = args.delegator {
                builder.add_delegator(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn delegator(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        StakeTx::VT_DELEGATOR,
                        None,
                    )
            }
        }
        #[inline]
        pub fn witness(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        StakeTx::VT_WITNESS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(StakeTx::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn nonce(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(StakeTx::VT_NONCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        StakeTx::VT_SIGNATURE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn gas_sponsorer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        StakeTx::VT_GAS_SPONSORER,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for StakeTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "delegator",
                    Self::VT_DELEGATOR,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "witness",
                    Self::VT_WITNESS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "signature",
                    Self::VT_SIGNATURE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "gas_sponsorer",
                    Self::VT_GAS_SPONSORER,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct StakeTxArgs<'a> {
        pub delegator: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub witness: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub amount: u64,
        pub nonce: u64,
        pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub gas_sponsorer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for StakeTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            StakeTxArgs {
                delegator: None,
                witness: None,
                amount: 0,
                nonce: 0,
                signature: None,
                gas_sponsorer: None,
            }
        }
    }

    pub struct StakeTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StakeTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_delegator(
            &mut self,
            delegator: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StakeTx::VT_DELEGATOR, delegator);
        }
        #[inline]
        pub fn add_witness(
            &mut self,
            witness: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StakeTx::VT_WITNESS, witness);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(StakeTx::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u64) {
            self.fbb_.push_slot::<u64>(StakeTx::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn add_signature(
            &mut self,
            signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(StakeTx::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn add_gas_sponsorer(
            &mut self,
            gas_sponsorer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                StakeTx::VT_GAS_SPONSORER,
                gas_sponsorer,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> StakeTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            StakeTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StakeTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for StakeTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("StakeTx");
            ds.field("delegator", &self.delegator());
            ds.field("witness", &self.witness());
            ds.field("amount", &self.amount());
            ds.field("nonce", &self.nonce());
            ds.field("signature", &self.signature());
            ds.field("gas_sponsorer", &self.gas_sponsorer());
            ds.finish()
        }
    }
    pub enum UnstakeTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct UnstakeTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for UnstakeTx<'a> {
        type Inner = UnstakeTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> UnstakeTx<'a> {
        pub const VT_DELEGATOR: flatbuffers::VOffsetT = 4;
        pub const VT_WITNESS: flatbuffers::VOffsetT = 6;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 8;
        pub const VT_NONCE: flatbuffers::VOffsetT = 10;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 12;
        pub const VT_GAS_SPONSORER: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            UnstakeTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args UnstakeTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<UnstakeTx<'bldr>> {
            let mut builder = UnstakeTxBuilder::new(_fbb);
            builder.add_nonce(args.nonce);
            builder.add_amount(args.amount);
            if let Some(x) = args.gas_sponsorer {
                builder.add_gas_sponsorer(x);
            }
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.witness {
                builder.add_witness(x);
            }
            if let Some(x) = args.delegator {
                builder.add_delegator(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn delegator(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        UnstakeTx::VT_DELEGATOR,
                        None,
                    )
            }
        }
        #[inline]
        pub fn witness(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        UnstakeTx::VT_WITNESS,
                        None,
                    )
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(UnstakeTx::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn nonce(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(UnstakeTx::VT_NONCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        UnstakeTx::VT_SIGNATURE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn gas_sponsorer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        UnstakeTx::VT_GAS_SPONSORER,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for UnstakeTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "delegator",
                    Self::VT_DELEGATOR,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "witness",
                    Self::VT_WITNESS,
                    false,
                )?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "signature",
                    Self::VT_SIGNATURE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "gas_sponsorer",
                    Self::VT_GAS_SPONSORER,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct UnstakeTxArgs<'a> {
        pub delegator: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub witness: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub amount: u64,
        pub nonce: u64,
        pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub gas_sponsorer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for UnstakeTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            UnstakeTxArgs {
                delegator: None,
                witness: None,
                amount: 0,
                nonce: 0,
                signature: None,
                gas_sponsorer: None,
            }
        }
    }

    pub struct UnstakeTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> UnstakeTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_delegator(
            &mut self,
            delegator: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UnstakeTx::VT_DELEGATOR, delegator);
        }
        #[inline]
        pub fn add_witness(
            &mut self,
            witness: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UnstakeTx::VT_WITNESS, witness);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(UnstakeTx::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u64) {
            self.fbb_.push_slot::<u64>(UnstakeTx::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn add_signature(
            &mut self,
            signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(UnstakeTx::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn add_gas_sponsorer(
            &mut self,
            gas_sponsorer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                UnstakeTx::VT_GAS_SPONSORER,
                gas_sponsorer,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> UnstakeTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            UnstakeTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<UnstakeTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for UnstakeTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("UnstakeTx");
            ds.field("delegator", &self.delegator());
            ds.field("witness", &self.witness());
            ds.field("amount", &self.amount());
            ds.field("nonce", &self.nonce());
            ds.field("signature", &self.signature());
            ds.field("gas_sponsorer", &self.gas_sponsorer());
            ds.finish()
        }
    }
    pub enum SolveTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SolveTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SolveTx<'a> {
        type Inner = SolveTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SolveTx<'a> {
        pub const VT_SENDER: flatbuffers::VOffsetT = 4;
        pub const VT_PROOF: flatbuffers::VOffsetT = 6;
        pub const VT_PUZZLE_ID: flatbuffers::VOffsetT = 8;
        pub const VT_NONCE: flatbuffers::VOffsetT = 10;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 12;
        pub const VT_GAS_SPONSORER: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SolveTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SolveTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<SolveTx<'bldr>> {
            let mut builder = SolveTxBuilder::new(_fbb);
            builder.add_nonce(args.nonce);
            if let Some(x) = args.gas_sponsorer {
                builder.add_gas_sponsorer(x);
            }
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.puzzle_id {
                builder.add_puzzle_id(x);
            }
            if let Some(x) = args.proof {
                builder.add_proof(x);
            }
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn sender(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SolveTx::VT_SENDER,
                        None,
                    )
            }
        }
        #[inline]
        pub fn proof(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SolveTx::VT_PROOF,
                        None,
                    )
            }
        }
        #[inline]
        pub fn puzzle_id(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SolveTx::VT_PUZZLE_ID,
                        None,
                    )
            }
        }
        #[inline]
        pub fn nonce(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(SolveTx::VT_NONCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn signature(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SolveTx::VT_SIGNATURE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn gas_sponsorer(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SolveTx::VT_GAS_SPONSORER,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for SolveTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "sender",
                    Self::VT_SENDER,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "proof",
                    Self::VT_PROOF,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "puzzle_id",
                    Self::VT_PUZZLE_ID,
                    false,
                )?
                .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "signature",
                    Self::VT_SIGNATURE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "gas_sponsorer",
                    Self::VT_GAS_SPONSORER,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SolveTxArgs<'a> {
        pub sender: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub proof: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub puzzle_id: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub nonce: u64,
        pub signature: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub gas_sponsorer: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for SolveTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            SolveTxArgs {
                sender: None,
                proof: None,
                puzzle_id: None,
                nonce: 0,
                signature: None,
                gas_sponsorer: None,
            }
        }
    }

    pub struct SolveTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SolveTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_sender(&mut self, sender: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SolveTx::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_proof(&mut self, proof: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SolveTx::VT_PROOF, proof);
        }
        #[inline]
        pub fn add_puzzle_id(
            &mut self,
            puzzle_id: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SolveTx::VT_PUZZLE_ID, puzzle_id);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u64) {
            self.fbb_.push_slot::<u64>(SolveTx::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn add_signature(
            &mut self,
            signature: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SolveTx::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn add_gas_sponsorer(
            &mut self,
            gas_sponsorer: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(
                SolveTx::VT_GAS_SPONSORER,
                gas_sponsorer,
            );
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SolveTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SolveTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SolveTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SolveTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SolveTx");
            ds.field("sender", &self.sender());
            ds.field("proof", &self.proof());
            ds.field("puzzle_id", &self.puzzle_id());
            ds.field("nonce", &self.nonce());
            ds.field("signature", &self.signature());
            ds.field("gas_sponsorer", &self.gas_sponsorer());
            ds.finish()
        }
    }
    pub enum TransactionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Transaction<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Transaction<'a> {
        type Inner = Transaction<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Transaction<'a> {
        pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_BODY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Transaction { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TransactionArgs,
        ) -> flatbuffers::WIPOffset<Transaction<'bldr>> {
            let mut builder = TransactionBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            builder.add_body_type(args.body_type);
            builder.finish()
        }

        #[inline]
        pub fn body_type(&self) -> TxBody {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TxBody>(Transaction::VT_BODY_TYPE, Some(TxBody::NONE))
                    .unwrap()
            }
        }
        #[inline]
        pub fn body(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        Transaction::VT_BODY,
                        None,
                    )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_send_tx(&self) -> Option<SendTx<'a>> {
            if self.body_type() == TxBody::SendTx {
                self.body().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SendTx::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_mint_tx(&self) -> Option<MintTx<'a>> {
            if self.body_type() == TxBody::MintTx {
                self.body().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { MintTx::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_burn_tx(&self) -> Option<BurnTx<'a>> {
            if self.body_type() == TxBody::BurnTx {
                self.body().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { BurnTx::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_stake_tx(&self) -> Option<StakeTx<'a>> {
            if self.body_type() == TxBody::StakeTx {
                self.body().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { StakeTx::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_unstake_tx(&self) -> Option<UnstakeTx<'a>> {
            if self.body_type() == TxBody::UnstakeTx {
                self.body().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { UnstakeTx::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_solve_tx(&self) -> Option<SolveTx<'a>> {
            if self.body_type() == TxBody::SolveTx {
                self.body().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SolveTx::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Transaction<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_union::<TxBody, _>(
                    "body_type",
                    Self::VT_BODY_TYPE,
                    "body",
                    Self::VT_BODY,
                    false,
                    |key, v, pos| match key {
                        TxBody::SendTx => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<SendTx>>(
                                "TxBody::SendTx",
                                pos,
                            ),
                        TxBody::MintTx => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<MintTx>>(
                                "TxBody::MintTx",
                                pos,
                            ),
                        TxBody::BurnTx => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<BurnTx>>(
                                "TxBody::BurnTx",
                                pos,
                            ),
                        TxBody::StakeTx => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<StakeTx>>(
                                "TxBody::StakeTx",
                                pos,
                            ),
                        TxBody::UnstakeTx => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<UnstakeTx>>(
                                "TxBody::UnstakeTx",
                                pos,
                            ),
                        TxBody::SolveTx => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<SolveTx>>(
                                "TxBody::SolveTx",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionArgs {
        pub body_type: TxBody,
        pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for TransactionArgs {
        #[inline]
        fn default() -> Self {
            TransactionArgs {
                body_type: TxBody::NONE,
                body: None,
            }
        }
    }

    pub struct TransactionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_body_type(&mut self, body_type: TxBody) {
            self.fbb_
                .push_slot::<TxBody>(Transaction::VT_BODY_TYPE, body_type, TxBody::NONE);
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_BODY, body);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TransactionBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TransactionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Transaction<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Transaction<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Transaction");
            ds.field("body_type", &self.body_type());
            match self.body_type() {
                TxBody::SendTx => {
                    if let Some(x) = self.body_as_send_tx() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                TxBody::MintTx => {
                    if let Some(x) = self.body_as_mint_tx() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                TxBody::BurnTx => {
                    if let Some(x) = self.body_as_burn_tx() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                TxBody::StakeTx => {
                    if let Some(x) = self.body_as_stake_tx() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                TxBody::UnstakeTx => {
                    if let Some(x) = self.body_as_unstake_tx() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                TxBody::SolveTx => {
                    if let Some(x) = self.body_as_solve_tx() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("body", &x)
                }
            };
            ds.finish()
        }
    }
    pub enum SealedTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SealedTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SealedTx<'a> {
        type Inner = SealedTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SealedTx<'a> {
        pub const VT_NONCE: flatbuffers::VOffsetT = 4;
        pub const VT_TAG: flatbuffers::VOffsetT = 6;
        pub const VT_CIPHERTEXT: flatbuffers::VOffsetT = 8;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SealedTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SealedTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<SealedTx<'bldr>> {
            let mut builder = SealedTxBuilder::new(_fbb);
            if let Some(x) = args.ciphertext {
                builder.add_ciphertext(x);
            }
            if let Some(x) = args.tag {
                builder.add_tag(x);
            }
            if let Some(x) = args.nonce {
                builder.add_nonce(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn nonce(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SealedTx::VT_NONCE,
                        None,
                    )
            }
        }
        #[inline]
        pub fn tag(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SealedTx::VT_TAG,
                        None,
                    )
            }
        }
        #[inline]
        pub fn ciphertext(&self) -> Option<flatbuffers::Vector<'a, u8>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(
                        SealedTx::VT_CIPHERTEXT,
                        None,
                    )
            }
        }
    }

    impl flatbuffers::Verifiable for SealedTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "nonce",
                    Self::VT_NONCE,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "tag",
                    Self::VT_TAG,
                    false,
                )?
                .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>(
                    "ciphertext",
                    Self::VT_CIPHERTEXT,
                    false,
                )?
                .finish();
            Ok(())
        }
    }
    pub struct SealedTxArgs<'a> {
        pub nonce: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub tag: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
        pub ciphertext: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    }
    impl<'a> Default for SealedTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            SealedTxArgs {
                nonce: None,
                tag: None,
                ciphertext: None,
            }
        }
    }

    pub struct SealedTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SealedTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_nonce(&mut self, nonce: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SealedTx::VT_NONCE, nonce);
        }
        #[inline]
        pub fn add_tag(&mut self, tag: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SealedTx::VT_TAG, tag);
        }
        #[inline]
        pub fn add_ciphertext(
            &mut self,
            ciphertext: flatbuffers::WIPOffset<flatbuffers::Vector<'b, u8>>,
        ) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(SealedTx::VT_CIPHERTEXT, ciphertext);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SealedTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SealedTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SealedTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SealedTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SealedTx");
            ds.field("nonce", &self.nonce());
            ds.field("tag", &self.tag());
            ds.field("ciphertext", &self.ciphertext());
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `Transaction`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_unchecked`.
    pub fn root_as_transaction(buf: &[u8]) -> Result<Transaction, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Transaction>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Transaction` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_transaction_unchecked`.
    pub fn size_prefixed_root_as_transaction(
        buf: &[u8],
    ) -> Result<Transaction, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Transaction>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Transaction` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_unchecked`.
    pub fn root_as_transaction_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Transaction<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Transaction<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Transaction` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_unchecked`.
    pub fn size_prefixed_root_as_transaction_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Transaction<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Transaction<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Transaction and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Transaction`.
    pub unsafe fn root_as_transaction_unchecked(buf: &[u8]) -> Transaction {
        flatbuffers::root_unchecked::<Transaction>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Transaction and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Transaction`.
    pub unsafe fn size_prefixed_root_as_transaction_unchecked(buf: &[u8]) -> Transaction {
        flatbuffers::size_prefixed_root_unchecked::<Transaction>(buf)
    }
    #[inline]
    pub fn finish_transaction_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<Transaction<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_transaction_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<Transaction<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod tx
