UNAME := $(shell uname)

ifneq (,$(findstring clang, $(shell $(CXX) --version)))
NOPIE = -fno-PIE
else
NOPIE = -no-pie
endif

LDFLAGS += -flto $(NOPIE) -g
LDLIBS += -lgmpxx -lgmp -lboost_system -pthread
CXXFLAGS += -flto -std=c++1z -D VDF_MODE=0 -D FAST_MACHINE=1 -pthread $(NOPIE) -fvisibility=hidden -fPIC
ifeq ($(UNAME),Darwin)
CXXFLAGS += -D CHIAOSX=1
endif

OPT_CFLAGS = -O3 -g

ifneq ($(ASAN),)
LDFLAGS += -fsanitize=address -fsanitize=undefined
CXXFLAGS += -g -fsanitize=address -fsanitize=undefined -fsanitize-undefined-trap-on-error
endif

ifneq ($(TSAN),)
LDFLAGS += -fsanitize=thread
CXXFLAGS += -g -fsanitize=thread
endif

.PHONY: all clean lib

# Original binaries
BINS = vdf_client prover_test 1weso_test 2weso_test vdf_bench

# New CPU VDF library targets - NOW INCLUDING ALL DEPENDENCIES
LIB_SHARED = libcpuvdf.so
LIB_STATIC = libcpuvdf.a
LIB_OBJS = streamer.o lzcnt.o vdf_base.o asm_compiled.o avx2_asm_compiled.o avx512_asm_compiled.o

all: $(BINS) lib

lib: $(LIB_SHARED) $(LIB_STATIC)

clean:
	rm -f *.o hw/*.o $(BINS) $(LIB_SHARED) $(LIB_STATIC) compile_asm emu_hw_test hw_test hw_vdf_client emu_hw_vdf_client
	rm -f asm_compiled.s avx2_asm_compiled.s avx512_asm_compiled.s

# Original binary targets
$(BINS) avx512_test: %: %.o lzcnt.o asm_compiled.o avx2_asm_compiled.o avx512_asm_compiled.o
	$(CXX) $(LDFLAGS) -o $@ $^ $(LDLIBS)

$(addsuffix .o,$(BINS)) avx512_test.o: CXXFLAGS += $(OPT_CFLAGS)

# CPU VDF Wrapper compilation
streamer.o: c_bindings/streamer.cpp c_bindings/streamer.h vdf_base.hpp include.h
	$(CXX) $(CXXFLAGS) $(OPT_CFLAGS) -I. -Ic_bindings -fPIC -c c_bindings/streamer.cpp -o $@

# VDF base objects
vdf_base.o: vdf_base.cpp vdf_base.hpp include.h
	$(CXX) $(CXXFLAGS) $(OPT_CFLAGS) -fPIC -c vdf_base.cpp -o $@

# lzcnt object
lzcnt.o: refcode/lzcnt.c
	$(CC) -O3 -fPIC -c refcode/lzcnt.c -o $@

# Assembly compilation
asm_compiled.s: compile_asm
	./compile_asm

avx2_asm_compiled.s: compile_asm
	./compile_asm avx2

avx512_asm_compiled.s: compile_asm
	./compile_asm avx512

# Assembly objects - use assembler directly, not C++ compiler
asm_compiled.o: asm_compiled.s
	$(AS) -o $@ asm_compiled.s

avx2_asm_compiled.o: avx2_asm_compiled.s
	$(AS) -o $@ avx2_asm_compiled.s

avx512_asm_compiled.o: avx512_asm_compiled.s
	$(AS) -o $@ avx512_asm_compiled.s

compile_asm: compile_asm.o
	$(CXX) $(LDFLAGS) -o $@ $^ $(LDLIBS)

compile_asm.o: compile_asm.cpp
	$(CXX) $(CXXFLAGS) $(OPT_CFLAGS) -c compile_asm.cpp -o $@

# Shared library - now includes all dependencies
$(LIB_SHARED): $(LIB_OBJS)
	$(CXX) $(LDFLAGS) -shared -fPIC -o $@ $^ $(LDLIBS)

# Static library - now includes all dependencies
$(LIB_STATIC): $(LIB_OBJS)
	ar rcs $@ $^

# Hardware VDF targets (original)
HW_OBJS = $(addprefix hw/,hw_util.o hw_proof.o hw_interface.o chia_driver.o ftdi_driver.o vdf_driver.o pll_freqs.o) vdf_base.o lzcnt.o
EMU_OBJS = hw/emu_funcs.o hw/emu_runner.o
HW_LIB = hw/libft4222/build-x86_64/libft4222.so

hw_test: hw/hw_test.o $(HW_OBJS) $(HW_LIB) hw/real_hw.o
	$(CXX) $(LDFLAGS) -o $@ $^ $(LDLIBS)

emu_hw_test: hw/hw_test.o $(HW_OBJS) $(EMU_OBJS)
	$(CXX) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hw_vdf_client: hw/hw_vdf_client.o $(HW_OBJS) $(HW_LIB) hw/real_hw.o
	$(CXX) $(LDFLAGS) -o $@ $^ $(LDLIBS)

emu_hw_vdf_client: hw/hw_vdf_client.o $(HW_OBJS) $(EMU_OBJS)
	$(CXX) $(LDFLAGS) -o $@ $^ $(LDLIBS)

hw/hw_test.o hw/hw_vdf_client.o $(HW_OBJS) $(EMU_OBJS): CXXFLAGS += -I.

# Install targets for library
install-lib: lib
	mkdir -p /usr/local/lib
	mkdir -p /usr/local/include
	cp $(LIB_SHARED) /usr/local/lib/
	cp $(LIB_STATIC) /usr/local/lib/
	cp c_bindings/streamer.h /usr/local/include/
	ldconfig

# Rust integration target
rust-bindings: lib
	cd rust_bindings && cargo build --release

# Test targets
test-cpu-vdf: $(LIB_SHARED)
	$(CXX) $(CXXFLAGS) -I. -Ic_bindings -L. test_cpu_vdf.cpp -lcpuvdf $(LDLIBS) -o test_cpu_vdf
	LD_LIBRARY_PATH=. ./test_cpu_vdf

# Example test program
test_cpu_vdf.cpp:
	@echo '#include "c_bindings/streamer.h"' > test_cpu_vdf.cpp
	@echo '#include <iostream>' >> test_cpu_vdf.cpp
	@echo '#include <cstring>' >> test_cpu_vdf.cpp
	@echo 'int main() {' >> test_cpu_vdf.cpp
	@echo '    cpu_vdf_config_t config;' >> test_cpu_vdf.cpp
	@echo '    cpu_vdf_config_init(&config);' >> test_cpu_vdf.cpp
	@echo '    auto ctx = cpu_vdf_create(&config);' >> test_cpu_vdf.cpp
	@echo '    if (!ctx) { std::cout << "Failed to create context" << std::endl; return 1; }' >> test_cpu_vdf.cpp
	@echo '    uint8_t challenge[32]; memset(challenge, 1, 32);' >> test_cpu_vdf.cpp
	@echo '    int result = cpu_vdf_start_computation(ctx, challenge, nullptr, 1000, 1024);' >> test_cpu_vdf.cpp
	@echo '    if (result == 0) {' >> test_cpu_vdf.cpp
	@echo '        cpu_vdf_wait_completion(ctx, 30000);' >> test_cpu_vdf.cpp
	@echo '        std::cout << "VDF computation completed: " << cpu_vdf_is_complete(ctx) << std::endl;' >> test_cpu_vdf.cpp
	@echo '    } else {' >> test_cpu_vdf.cpp
	@echo '        std::cout << "Failed to start computation: " << result << std::endl;' >> test_cpu_vdf.cpp
	@echo '    }' >> test_cpu_vdf.cpp
	@echo '    cpu_vdf_destroy(ctx);' >> test_cpu_vdf.cpp
	@echo '    return 0;' >> test_cpu_vdf.cpp
	@echo '}' >> test_cpu_vdf.cpp

# Benchmark target
benchmark-cpu-vdf: $(LIB_SHARED)
	$(CXX) $(CXXFLAGS) -I. -Ic_bindings -L. benchmark_cpu_vdf.cpp -lcpuvdf $(LDLIBS) -o benchmark_cpu_vdf
	LD_LIBRARY_PATH=. ./benchmark_cpu_vdf

benchmark_cpu_vdf.cpp:
	@echo '#include "c_bindings/streamer.h"' > benchmark_cpu_vdf.cpp
	@echo '#include <iostream>' >> benchmark_cpu_vdf.cpp
	@echo '#include <chrono>' >> benchmark_cpu_vdf.cpp
	@echo 'int main() {' >> benchmark_cpu_vdf.cpp
	@echo '    cpu_vdf_config_t config;' >> benchmark_cpu_vdf.cpp
	@echo '    cpu_vdf_config_init(&config);' >> benchmark_cpu_vdf.cpp
	@echo '    std::cout << "Running CPU VDF benchmark..." << std::endl;' >> benchmark_cpu_vdf.cpp
	@echo '    double ips = cpu_vdf_benchmark(&config, 10000);' >> benchmark_cpu_vdf.cpp
	@echo '    if (ips > 0) {' >> benchmark_cpu_vdf.cpp
	@echo '        std::cout << "Benchmark result: " << ips << " iterations/second" << std::endl;' >> benchmark_cpu_vdf.cpp
	@echo '    } else {' >> benchmark_cpu_vdf.cpp
	@echo '        std::cout << "Benchmark failed" << std::endl;' >> benchmark_cpu_vdf.cpp
	@echo '    }' >> benchmark_cpu_vdf.cpp
	@echo '    cpu_vdf_capabilities_t caps;' >> benchmark_cpu_vdf.cpp
	@echo '    cpu_vdf_get_capabilities(&caps);' >> benchmark_cpu_vdf.cpp
	@echo '    std::cout << "CPU Cores: " << caps.cpu_cores << std::endl;' >> benchmark_cpu_vdf.cpp
	@echo '    std::cout << "AVX2: " << (caps.has_avx2 ? "Yes" : "No") << std::endl;' >> benchmark_cpu_vdf.cpp
	@echo '    std::cout << "AVX512: " << (caps.has_avx512 ? "Yes" : "No") << std::endl;' >> benchmark_cpu_vdf.cpp
	@echo '    return 0;' >> benchmark_cpu_vdf.cpp
	@echo '}' >> benchmark_cpu_vdf.cpp

# Test with test_streamer.cpp - use static library instead
test-streamer: $(LIB_STATIC)
	$(CXX) $(CXXFLAGS) -I. -Ic_bindings test_streamer.cpp $(LIB_STATIC) $(LDLIBS) -o test_streamer
	./test_streamer

# Documentation
doc:
	@echo "CPU VDF Wrapper Library"
	@echo "======================="
	@echo ""
	@echo "Build targets:"
	@echo "  all              - Build all binaries and libraries"
	@echo "  lib              - Build shared and static libraries"
	@echo "  install-lib      - Install libraries to system"
	@echo "  rust-bindings    - Build Rust bindings"
	@echo "  test-cpu-vdf     - Build and run CPU VDF test"
	@echo "  test-streamer    - Build and run test_streamer.cpp"
	@echo "  benchmark-cpu-vdf - Build and run CPU VDF benchmark"
	@echo ""
	@echo "Library files:"
	@echo "  libcpuvdf.so     - Shared library"
	@echo "  libcpuvdf.a      - Static library"
	@echo "  streamer.h       - C header file"
	@echo ""
	@echo "Usage example:"
	@echo "  #include \"streamer.h\""
	@echo "  // See test_cpu_vdf.cpp for complete example"

.PHONY: doc test-cpu-vdf benchmark-cpu-vdf install-lib rust-bindings test-streamer