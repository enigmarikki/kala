// automatically generated by the FlatBuffers compiler, do not modify

// @generated

use core::cmp::Ordering;
use core::mem;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod tx {

    use core::cmp::Ordering;
    use core::mem;

    extern crate flatbuffers;
    use self::flatbuffers::{EndianScalar, Follow};

    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MIN_TX_BODY: u8 = 0;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    pub const ENUM_MAX_TX_BODY: u8 = 4;
    #[deprecated(
        since = "2.0.0",
        note = "Use associated constants instead. This will no longer be generated in 2021."
    )]
    #[allow(non_camel_case_types)]
    pub const ENUM_VALUES_TX_BODY: [TxBody; 5] = [
        TxBody::NONE,
        TxBody::SendTx,
        TxBody::MintTx,
        TxBody::StakeTx,
        TxBody::SolveTx,
    ];

    #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
    #[repr(transparent)]
    pub struct TxBody(pub u8);
    #[allow(non_upper_case_globals)]
    impl TxBody {
        pub const NONE: Self = Self(0);
        pub const SendTx: Self = Self(1);
        pub const MintTx: Self = Self(2);
        pub const StakeTx: Self = Self(3);
        pub const SolveTx: Self = Self(4);

        pub const ENUM_MIN: u8 = 0;
        pub const ENUM_MAX: u8 = 4;
        pub const ENUM_VALUES: &'static [Self] = &[
            Self::NONE,
            Self::SendTx,
            Self::MintTx,
            Self::StakeTx,
            Self::SolveTx,
        ];
        /// Returns the variant's name or "" if unknown.
        pub fn variant_name(self) -> Option<&'static str> {
            match self {
                Self::NONE => Some("NONE"),
                Self::SendTx => Some("SendTx"),
                Self::MintTx => Some("MintTx"),
                Self::StakeTx => Some("StakeTx"),
                Self::SolveTx => Some("SolveTx"),
                _ => None,
            }
        }
    }
    impl core::fmt::Debug for TxBody {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            if let Some(name) = self.variant_name() {
                f.write_str(name)
            } else {
                f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
            }
        }
    }
    impl<'a> flatbuffers::Follow<'a> for TxBody {
        type Inner = Self;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            let b = flatbuffers::read_scalar_at::<u8>(buf, loc);
            Self(b)
        }
    }

    impl flatbuffers::Push for TxBody {
        type Output = TxBody;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            flatbuffers::emplace_scalar::<u8>(dst, self.0);
        }
    }

    impl flatbuffers::EndianScalar for TxBody {
        type Scalar = u8;
        #[inline]
        fn to_little_endian(self) -> u8 {
            self.0.to_le()
        }
        #[inline]
        #[allow(clippy::wrong_self_convention)]
        fn from_little_endian(v: u8) -> Self {
            let b = u8::from_le(v);
            Self(b)
        }
    }

    impl<'a> flatbuffers::Verifiable for TxBody {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            u8::run_verifier(v, pos)
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for TxBody {}
    pub struct TxBodyUnionTableOffset {}

    // struct Bytes32, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Bytes32(pub [u8; 32]);
    impl Default for Bytes32 {
        fn default() -> Self {
            Self([0; 32])
        }
    }
    impl core::fmt::Debug for Bytes32 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Bytes32")
                .field("data", &self.data())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Bytes32 {}
    impl<'a> flatbuffers::Follow<'a> for Bytes32 {
        type Inner = &'a Bytes32;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Bytes32>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Bytes32 {
        type Inner = &'a Bytes32;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Bytes32>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Bytes32 {
        type Output = Bytes32;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const Bytes32 as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for Bytes32 {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Bytes32 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(data: &[u8; 32]) -> Self {
            let mut s = Self([0; 32]);
            s.set_data(data);
            s
        }

        pub fn data(&'a self) -> flatbuffers::Array<'a, u8, 32> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 0) }
        }

        pub fn set_data(&mut self, items: &[u8; 32]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
        }
    }

    // struct Bytes64, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Bytes64(pub [u8; 64]);
    impl Default for Bytes64 {
        fn default() -> Self {
            Self([0; 64])
        }
    }
    impl core::fmt::Debug for Bytes64 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Bytes64")
                .field("data", &self.data())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Bytes64 {}
    impl<'a> flatbuffers::Follow<'a> for Bytes64 {
        type Inner = &'a Bytes64;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Bytes64>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Bytes64 {
        type Inner = &'a Bytes64;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Bytes64>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Bytes64 {
        type Output = Bytes64;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const Bytes64 as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for Bytes64 {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Bytes64 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(data: &[u8; 64]) -> Self {
            let mut s = Self([0; 64]);
            s.set_data(data);
            s
        }

        pub fn data(&'a self) -> flatbuffers::Array<'a, u8, 64> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 0) }
        }

        pub fn set_data(&mut self, items: &[u8; 64]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
        }
    }

    // struct Bytes256, aligned to 1
    #[repr(transparent)]
    #[derive(Clone, Copy, PartialEq)]
    pub struct Bytes256(pub [u8; 256]);
    impl Default for Bytes256 {
        fn default() -> Self {
            Self([0; 256])
        }
    }
    impl core::fmt::Debug for Bytes256 {
        fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
            f.debug_struct("Bytes256")
                .field("data", &self.data())
                .finish()
        }
    }

    impl flatbuffers::SimpleToVerifyInSlice for Bytes256 {}
    impl<'a> flatbuffers::Follow<'a> for Bytes256 {
        type Inner = &'a Bytes256;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            <&'a Bytes256>::follow(buf, loc)
        }
    }
    impl<'a> flatbuffers::Follow<'a> for &'a Bytes256 {
        type Inner = &'a Bytes256;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            flatbuffers::follow_cast_ref::<Bytes256>(buf, loc)
        }
    }
    impl<'b> flatbuffers::Push for Bytes256 {
        type Output = Bytes256;
        #[inline]
        unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
            let src = ::core::slice::from_raw_parts(
                self as *const Bytes256 as *const u8,
                <Self as flatbuffers::Push>::size(),
            );
            dst.copy_from_slice(src);
        }
        #[inline]
        fn alignment() -> flatbuffers::PushAlignment {
            flatbuffers::PushAlignment::new(1)
        }
    }

    impl<'a> flatbuffers::Verifiable for Bytes256 {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.in_buffer::<Self>(pos)
        }
    }

    impl<'a> Bytes256 {
        #[allow(clippy::too_many_arguments)]
        pub fn new(data: &[u8; 256]) -> Self {
            let mut s = Self([0; 256]);
            s.set_data(data);
            s
        }

        pub fn data(&'a self) -> flatbuffers::Array<'a, u8, 256> {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::Array::follow(&self.0, 0) }
        }

        pub fn set_data(&mut self, items: &[u8; 256]) {
            // Safety:
            // Created from a valid Table for this object
            // Which contains a valid array in this slot
            unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
        }
    }

    pub enum SendTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SendTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SendTx<'a> {
        type Inner = SendTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SendTx<'a> {
        pub const VT_SENDER: flatbuffers::VOffsetT = 4;
        pub const VT_RECEIVER: flatbuffers::VOffsetT = 6;
        pub const VT_DENOM: flatbuffers::VOffsetT = 8;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 10;
        pub const VT_NONCE: flatbuffers::VOffsetT = 12;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 14;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SendTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SendTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<SendTx<'bldr>> {
            let mut builder = SendTxBuilder::new(_fbb);
            builder.add_nonce(args.nonce);
            builder.add_amount(args.amount);
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.denom {
                builder.add_denom(x);
            }
            if let Some(x) = args.receiver {
                builder.add_receiver(x);
            }
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn sender(&self) -> Option<&'a Bytes32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes32>(SendTx::VT_SENDER, None) }
        }
        #[inline]
        pub fn receiver(&self) -> Option<&'a Bytes32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes32>(SendTx::VT_RECEIVER, None) }
        }
        #[inline]
        pub fn denom(&self) -> Option<&'a Bytes32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes32>(SendTx::VT_DENOM, None) }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(SendTx::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn nonce(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(SendTx::VT_NONCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn signature(&self) -> Option<&'a Bytes64> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes64>(SendTx::VT_SIGNATURE, None) }
        }
    }

    impl flatbuffers::Verifiable for SendTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Bytes32>("sender", Self::VT_SENDER, false)?
                .visit_field::<Bytes32>("receiver", Self::VT_RECEIVER, false)?
                .visit_field::<Bytes32>("denom", Self::VT_DENOM, false)?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
                .visit_field::<Bytes64>("signature", Self::VT_SIGNATURE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SendTxArgs<'a> {
        pub sender: Option<&'a Bytes32>,
        pub receiver: Option<&'a Bytes32>,
        pub denom: Option<&'a Bytes32>,
        pub amount: u64,
        pub nonce: u64,
        pub signature: Option<&'a Bytes64>,
    }
    impl<'a> Default for SendTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            SendTxArgs {
                sender: None,
                receiver: None,
                denom: None,
                amount: 0,
                nonce: 0,
                signature: None,
            }
        }
    }

    pub struct SendTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SendTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_sender(&mut self, sender: &Bytes32) {
            self.fbb_
                .push_slot_always::<&Bytes32>(SendTx::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_receiver(&mut self, receiver: &Bytes32) {
            self.fbb_
                .push_slot_always::<&Bytes32>(SendTx::VT_RECEIVER, receiver);
        }
        #[inline]
        pub fn add_denom(&mut self, denom: &Bytes32) {
            self.fbb_
                .push_slot_always::<&Bytes32>(SendTx::VT_DENOM, denom);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(SendTx::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u64) {
            self.fbb_.push_slot::<u64>(SendTx::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn add_signature(&mut self, signature: &Bytes64) {
            self.fbb_
                .push_slot_always::<&Bytes64>(SendTx::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SendTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SendTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SendTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SendTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SendTx");
            ds.field("sender", &self.sender());
            ds.field("receiver", &self.receiver());
            ds.field("denom", &self.denom());
            ds.field("amount", &self.amount());
            ds.field("nonce", &self.nonce());
            ds.field("signature", &self.signature());
            ds.finish()
        }
    }
    pub enum MintTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct MintTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for MintTx<'a> {
        type Inner = MintTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> MintTx<'a> {
        pub const VT_SENDER: flatbuffers::VOffsetT = 4;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 6;
        pub const VT_DENOM: flatbuffers::VOffsetT = 8;
        pub const VT_NONCE: flatbuffers::VOffsetT = 10;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            MintTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args MintTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<MintTx<'bldr>> {
            let mut builder = MintTxBuilder::new(_fbb);
            builder.add_nonce(args.nonce);
            builder.add_amount(args.amount);
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.denom {
                builder.add_denom(x);
            }
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn sender(&self) -> Option<&'a Bytes32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes32>(MintTx::VT_SENDER, None) }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(MintTx::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn denom(&self) -> Option<&'a Bytes32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes32>(MintTx::VT_DENOM, None) }
        }
        #[inline]
        pub fn nonce(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(MintTx::VT_NONCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn signature(&self) -> Option<&'a Bytes64> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes64>(MintTx::VT_SIGNATURE, None) }
        }
    }

    impl flatbuffers::Verifiable for MintTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Bytes32>("sender", Self::VT_SENDER, false)?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<Bytes32>("denom", Self::VT_DENOM, false)?
                .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
                .visit_field::<Bytes64>("signature", Self::VT_SIGNATURE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct MintTxArgs<'a> {
        pub sender: Option<&'a Bytes32>,
        pub amount: u64,
        pub denom: Option<&'a Bytes32>,
        pub nonce: u64,
        pub signature: Option<&'a Bytes64>,
    }
    impl<'a> Default for MintTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            MintTxArgs {
                sender: None,
                amount: 0,
                denom: None,
                nonce: 0,
                signature: None,
            }
        }
    }

    pub struct MintTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MintTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_sender(&mut self, sender: &Bytes32) {
            self.fbb_
                .push_slot_always::<&Bytes32>(MintTx::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(MintTx::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_denom(&mut self, denom: &Bytes32) {
            self.fbb_
                .push_slot_always::<&Bytes32>(MintTx::VT_DENOM, denom);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u64) {
            self.fbb_.push_slot::<u64>(MintTx::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn add_signature(&mut self, signature: &Bytes64) {
            self.fbb_
                .push_slot_always::<&Bytes64>(MintTx::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> MintTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            MintTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<MintTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for MintTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("MintTx");
            ds.field("sender", &self.sender());
            ds.field("amount", &self.amount());
            ds.field("denom", &self.denom());
            ds.field("nonce", &self.nonce());
            ds.field("signature", &self.signature());
            ds.finish()
        }
    }
    pub enum StakeTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct StakeTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for StakeTx<'a> {
        type Inner = StakeTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> StakeTx<'a> {
        pub const VT_SENDER: flatbuffers::VOffsetT = 4;
        pub const VT_DELEGATION_RECEIVER: flatbuffers::VOffsetT = 6;
        pub const VT_AMOUNT: flatbuffers::VOffsetT = 8;
        pub const VT_NONCE: flatbuffers::VOffsetT = 10;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            StakeTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args StakeTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<StakeTx<'bldr>> {
            let mut builder = StakeTxBuilder::new(_fbb);
            builder.add_nonce(args.nonce);
            builder.add_amount(args.amount);
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.delegation_receiver {
                builder.add_delegation_receiver(x);
            }
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn sender(&self) -> Option<&'a Bytes32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes32>(StakeTx::VT_SENDER, None) }
        }
        #[inline]
        pub fn delegation_receiver(&self) -> Option<&'a Bytes32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<Bytes32>(StakeTx::VT_DELEGATION_RECEIVER, None)
            }
        }
        #[inline]
        pub fn amount(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(StakeTx::VT_AMOUNT, Some(0)).unwrap() }
        }
        #[inline]
        pub fn nonce(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(StakeTx::VT_NONCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn signature(&self) -> Option<&'a Bytes64> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes64>(StakeTx::VT_SIGNATURE, None) }
        }
    }

    impl flatbuffers::Verifiable for StakeTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Bytes32>("sender", Self::VT_SENDER, false)?
                .visit_field::<Bytes32>("delegation_receiver", Self::VT_DELEGATION_RECEIVER, false)?
                .visit_field::<u64>("amount", Self::VT_AMOUNT, false)?
                .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
                .visit_field::<Bytes64>("signature", Self::VT_SIGNATURE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct StakeTxArgs<'a> {
        pub sender: Option<&'a Bytes32>,
        pub delegation_receiver: Option<&'a Bytes32>,
        pub amount: u64,
        pub nonce: u64,
        pub signature: Option<&'a Bytes64>,
    }
    impl<'a> Default for StakeTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            StakeTxArgs {
                sender: None,
                delegation_receiver: None,
                amount: 0,
                nonce: 0,
                signature: None,
            }
        }
    }

    pub struct StakeTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StakeTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_sender(&mut self, sender: &Bytes32) {
            self.fbb_
                .push_slot_always::<&Bytes32>(StakeTx::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_delegation_receiver(&mut self, delegation_receiver: &Bytes32) {
            self.fbb_
                .push_slot_always::<&Bytes32>(StakeTx::VT_DELEGATION_RECEIVER, delegation_receiver);
        }
        #[inline]
        pub fn add_amount(&mut self, amount: u64) {
            self.fbb_.push_slot::<u64>(StakeTx::VT_AMOUNT, amount, 0);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u64) {
            self.fbb_.push_slot::<u64>(StakeTx::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn add_signature(&mut self, signature: &Bytes64) {
            self.fbb_
                .push_slot_always::<&Bytes64>(StakeTx::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> StakeTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            StakeTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<StakeTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for StakeTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("StakeTx");
            ds.field("sender", &self.sender());
            ds.field("delegation_receiver", &self.delegation_receiver());
            ds.field("amount", &self.amount());
            ds.field("nonce", &self.nonce());
            ds.field("signature", &self.signature());
            ds.finish()
        }
    }
    pub enum SolveTxOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct SolveTx<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for SolveTx<'a> {
        type Inner = SolveTx<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> SolveTx<'a> {
        pub const VT_SENDER: flatbuffers::VOffsetT = 4;
        pub const VT_PROOF: flatbuffers::VOffsetT = 6;
        pub const VT_PUZZLE_ID: flatbuffers::VOffsetT = 8;
        pub const VT_NONCE: flatbuffers::VOffsetT = 10;
        pub const VT_SIGNATURE: flatbuffers::VOffsetT = 12;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            SolveTx { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args SolveTxArgs<'args>,
        ) -> flatbuffers::WIPOffset<SolveTx<'bldr>> {
            let mut builder = SolveTxBuilder::new(_fbb);
            builder.add_nonce(args.nonce);
            if let Some(x) = args.signature {
                builder.add_signature(x);
            }
            if let Some(x) = args.puzzle_id {
                builder.add_puzzle_id(x);
            }
            if let Some(x) = args.proof {
                builder.add_proof(x);
            }
            if let Some(x) = args.sender {
                builder.add_sender(x);
            }
            builder.finish()
        }

        #[inline]
        pub fn sender(&self) -> Option<&'a Bytes32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes32>(SolveTx::VT_SENDER, None) }
        }
        #[inline]
        pub fn proof(&self) -> Option<&'a Bytes256> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes256>(SolveTx::VT_PROOF, None) }
        }
        #[inline]
        pub fn puzzle_id(&self) -> Option<&'a Bytes32> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes32>(SolveTx::VT_PUZZLE_ID, None) }
        }
        #[inline]
        pub fn nonce(&self) -> u64 {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<u64>(SolveTx::VT_NONCE, Some(0)).unwrap() }
        }
        #[inline]
        pub fn signature(&self) -> Option<&'a Bytes64> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe { self._tab.get::<Bytes64>(SolveTx::VT_SIGNATURE, None) }
        }
    }

    impl flatbuffers::Verifiable for SolveTx<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_field::<Bytes32>("sender", Self::VT_SENDER, false)?
                .visit_field::<Bytes256>("proof", Self::VT_PROOF, false)?
                .visit_field::<Bytes32>("puzzle_id", Self::VT_PUZZLE_ID, false)?
                .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
                .visit_field::<Bytes64>("signature", Self::VT_SIGNATURE, false)?
                .finish();
            Ok(())
        }
    }
    pub struct SolveTxArgs<'a> {
        pub sender: Option<&'a Bytes32>,
        pub proof: Option<&'a Bytes256>,
        pub puzzle_id: Option<&'a Bytes32>,
        pub nonce: u64,
        pub signature: Option<&'a Bytes64>,
    }
    impl<'a> Default for SolveTxArgs<'a> {
        #[inline]
        fn default() -> Self {
            SolveTxArgs {
                sender: None,
                proof: None,
                puzzle_id: None,
                nonce: 0,
                signature: None,
            }
        }
    }

    pub struct SolveTxBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SolveTxBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_sender(&mut self, sender: &Bytes32) {
            self.fbb_
                .push_slot_always::<&Bytes32>(SolveTx::VT_SENDER, sender);
        }
        #[inline]
        pub fn add_proof(&mut self, proof: &Bytes256) {
            self.fbb_
                .push_slot_always::<&Bytes256>(SolveTx::VT_PROOF, proof);
        }
        #[inline]
        pub fn add_puzzle_id(&mut self, puzzle_id: &Bytes32) {
            self.fbb_
                .push_slot_always::<&Bytes32>(SolveTx::VT_PUZZLE_ID, puzzle_id);
        }
        #[inline]
        pub fn add_nonce(&mut self, nonce: u64) {
            self.fbb_.push_slot::<u64>(SolveTx::VT_NONCE, nonce, 0);
        }
        #[inline]
        pub fn add_signature(&mut self, signature: &Bytes64) {
            self.fbb_
                .push_slot_always::<&Bytes64>(SolveTx::VT_SIGNATURE, signature);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> SolveTxBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            SolveTxBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<SolveTx<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for SolveTx<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("SolveTx");
            ds.field("sender", &self.sender());
            ds.field("proof", &self.proof());
            ds.field("puzzle_id", &self.puzzle_id());
            ds.field("nonce", &self.nonce());
            ds.field("signature", &self.signature());
            ds.finish()
        }
    }
    pub enum TransactionOffset {}
    #[derive(Copy, Clone, PartialEq)]

    pub struct Transaction<'a> {
        pub _tab: flatbuffers::Table<'a>,
    }

    impl<'a> flatbuffers::Follow<'a> for Transaction<'a> {
        type Inner = Transaction<'a>;
        #[inline]
        unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
            Self {
                _tab: flatbuffers::Table::new(buf, loc),
            }
        }
    }

    impl<'a> Transaction<'a> {
        pub const VT_BODY_TYPE: flatbuffers::VOffsetT = 4;
        pub const VT_BODY: flatbuffers::VOffsetT = 6;

        #[inline]
        pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
            Transaction { _tab: table }
        }
        #[allow(unused_mut)]
        pub fn create<
            'bldr: 'args,
            'args: 'mut_bldr,
            'mut_bldr,
            A: flatbuffers::Allocator + 'bldr,
        >(
            _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
            args: &'args TransactionArgs,
        ) -> flatbuffers::WIPOffset<Transaction<'bldr>> {
            let mut builder = TransactionBuilder::new(_fbb);
            if let Some(x) = args.body {
                builder.add_body(x);
            }
            builder.add_body_type(args.body_type);
            builder.finish()
        }

        #[inline]
        pub fn body_type(&self) -> TxBody {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<TxBody>(Transaction::VT_BODY_TYPE, Some(TxBody::NONE))
                    .unwrap()
            }
        }
        #[inline]
        pub fn body(&self) -> Option<flatbuffers::Table<'a>> {
            // Safety:
            // Created from valid Table for this object
            // which contains a valid value in this slot
            unsafe {
                self._tab
                    .get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(
                        Transaction::VT_BODY,
                        None,
                    )
            }
        }
        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_send_tx(&self) -> Option<SendTx<'a>> {
            if self.body_type() == TxBody::SendTx {
                self.body().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SendTx::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_mint_tx(&self) -> Option<MintTx<'a>> {
            if self.body_type() == TxBody::MintTx {
                self.body().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { MintTx::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_stake_tx(&self) -> Option<StakeTx<'a>> {
            if self.body_type() == TxBody::StakeTx {
                self.body().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { StakeTx::init_from_table(t) }
                })
            } else {
                None
            }
        }

        #[inline]
        #[allow(non_snake_case)]
        pub fn body_as_solve_tx(&self) -> Option<SolveTx<'a>> {
            if self.body_type() == TxBody::SolveTx {
                self.body().map(|t| {
                    // Safety:
                    // Created from a valid Table for this object
                    // Which contains a valid union in this slot
                    unsafe { SolveTx::init_from_table(t) }
                })
            } else {
                None
            }
        }
    }

    impl flatbuffers::Verifiable for Transaction<'_> {
        #[inline]
        fn run_verifier(
            v: &mut flatbuffers::Verifier,
            pos: usize,
        ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
            use self::flatbuffers::Verifiable;
            v.visit_table(pos)?
                .visit_union::<TxBody, _>(
                    "body_type",
                    Self::VT_BODY_TYPE,
                    "body",
                    Self::VT_BODY,
                    false,
                    |key, v, pos| match key {
                        TxBody::SendTx => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<SendTx>>(
                                "TxBody::SendTx",
                                pos,
                            ),
                        TxBody::MintTx => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<MintTx>>(
                                "TxBody::MintTx",
                                pos,
                            ),
                        TxBody::StakeTx => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<StakeTx>>(
                                "TxBody::StakeTx",
                                pos,
                            ),
                        TxBody::SolveTx => v
                            .verify_union_variant::<flatbuffers::ForwardsUOffset<SolveTx>>(
                                "TxBody::SolveTx",
                                pos,
                            ),
                        _ => Ok(()),
                    },
                )?
                .finish();
            Ok(())
        }
    }
    pub struct TransactionArgs {
        pub body_type: TxBody,
        pub body: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    }
    impl<'a> Default for TransactionArgs {
        #[inline]
        fn default() -> Self {
            TransactionArgs {
                body_type: TxBody::NONE,
                body: None,
            }
        }
    }

    pub struct TransactionBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
        fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
    }
    impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> TransactionBuilder<'a, 'b, A> {
        #[inline]
        pub fn add_body_type(&mut self, body_type: TxBody) {
            self.fbb_
                .push_slot::<TxBody>(Transaction::VT_BODY_TYPE, body_type, TxBody::NONE);
        }
        #[inline]
        pub fn add_body(&mut self, body: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
            self.fbb_
                .push_slot_always::<flatbuffers::WIPOffset<_>>(Transaction::VT_BODY, body);
        }
        #[inline]
        pub fn new(
            _fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        ) -> TransactionBuilder<'a, 'b, A> {
            let start = _fbb.start_table();
            TransactionBuilder {
                fbb_: _fbb,
                start_: start,
            }
        }
        #[inline]
        pub fn finish(self) -> flatbuffers::WIPOffset<Transaction<'a>> {
            let o = self.fbb_.end_table(self.start_);
            flatbuffers::WIPOffset::new(o.value())
        }
    }

    impl core::fmt::Debug for Transaction<'_> {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            let mut ds = f.debug_struct("Transaction");
            ds.field("body_type", &self.body_type());
            match self.body_type() {
                TxBody::SendTx => {
                    if let Some(x) = self.body_as_send_tx() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                TxBody::MintTx => {
                    if let Some(x) = self.body_as_mint_tx() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                TxBody::StakeTx => {
                    if let Some(x) = self.body_as_stake_tx() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                TxBody::SolveTx => {
                    if let Some(x) = self.body_as_solve_tx() {
                        ds.field("body", &x)
                    } else {
                        ds.field(
                            "body",
                            &"InvalidFlatbuffer: Union discriminant does not match value.",
                        )
                    }
                }
                _ => {
                    let x: Option<()> = None;
                    ds.field("body", &x)
                }
            };
            ds.finish()
        }
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a `Transaction`
    /// and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_unchecked`.
    pub fn root_as_transaction(buf: &[u8]) -> Result<Transaction, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root::<Transaction>(buf)
    }
    #[inline]
    /// Verifies that a buffer of bytes contains a size prefixed
    /// `Transaction` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `size_prefixed_root_as_transaction_unchecked`.
    pub fn size_prefixed_root_as_transaction(
        buf: &[u8],
    ) -> Result<Transaction, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root::<Transaction>(buf)
    }
    #[inline]
    /// Verifies, with the given options, that a buffer of bytes
    /// contains a `Transaction` and returns it.
    /// Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_unchecked`.
    pub fn root_as_transaction_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Transaction<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::root_with_opts::<Transaction<'b>>(opts, buf)
    }
    #[inline]
    /// Verifies, with the given verifier options, that a buffer of
    /// bytes contains a size prefixed `Transaction` and returns
    /// it. Note that verification is still experimental and may not
    /// catch every error, or be maximally performant. For the
    /// previous, unchecked, behavior use
    /// `root_as_transaction_unchecked`.
    pub fn size_prefixed_root_as_transaction_with_opts<'b, 'o>(
        opts: &'o flatbuffers::VerifierOptions,
        buf: &'b [u8],
    ) -> Result<Transaction<'b>, flatbuffers::InvalidFlatbuffer> {
        flatbuffers::size_prefixed_root_with_opts::<Transaction<'b>>(opts, buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a Transaction and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid `Transaction`.
    pub unsafe fn root_as_transaction_unchecked(buf: &[u8]) -> Transaction {
        flatbuffers::root_unchecked::<Transaction>(buf)
    }
    #[inline]
    /// Assumes, without verification, that a buffer of bytes contains a size prefixed Transaction and returns it.
    /// # Safety
    /// Callers must trust the given bytes do indeed contain a valid size prefixed `Transaction`.
    pub unsafe fn size_prefixed_root_as_transaction_unchecked(buf: &[u8]) -> Transaction {
        flatbuffers::size_prefixed_root_unchecked::<Transaction>(buf)
    }
    #[inline]
    pub fn finish_transaction_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<Transaction<'a>>,
    ) {
        fbb.finish(root, None);
    }

    #[inline]
    pub fn finish_size_prefixed_transaction_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
        fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
        root: flatbuffers::WIPOffset<Transaction<'a>>,
    ) {
        fbb.finish_size_prefixed(root, None);
    }
} // pub mod tx
